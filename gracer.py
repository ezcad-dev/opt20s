# -*- coding: utf-8 -*-
# Copyright (c) Ezcad Development Team. All Rights Reserved.
"""
Zoeppritz partial derivatives
"""

from math import pi, sin, cos, sqrt
from modcer import rpp_cer1977, rps_cer1977, physics_check


def main():
    pass


def gradient(r1, r2, r3, r4, angle, mode, rid, method='numeric', delta=0.001):
    gra = 0
    if method is 'numeric':
        gra = pdn(r1, r2, r3, r4, angle, mode, rid, delta=delta)
    elif method is 'analytic':
        if mode is 'PP':
            if rid == 1:
                gra = ppr1(r1, r2, r3, r4, angle)
            elif rid == 2:
                gra = ppr2(r1, r2, r3, r4, angle)
            elif rid == 3:
                gra = ppr3(r1, r2, r3, r4, angle)
            elif rid == 4:
                gra = ppr4(r1, r2, r3, r4, angle)
            else:
                raise ValueError("Illegal ratio index")
        elif mode is 'PS':
            if rid == 1:
                gra = psr1(r1, r2, r3, r4, angle)
            elif rid == 2:
                gra = psr2(r1, r2, r3, r4, angle)
            elif rid == 3:
                gra = psr3(r1, r2, r3, r4, angle)
            elif rid == 4:
                gra = psr4(r1, r2, r3, r4, angle)
            else:
                raise ValueError("Illegal ratio index")
        else:
            raise ValueError("Unsupported wave mode")
    else:
        raise ValueError("Illegal method")
    return gra


def stability_check(r1, angle):
    # require Vp1 > Vp2, i.e., r1 < 1
    if (r1 * sin(angle)) >= 1:
        raise ValueError("Cannot handle post-critical angle")
    # Physically, Vp always larger than Vs, so
    # alpha1 > beta1, alpha2 > beta2
    # if assumes alpha1 > alpha2, it follows that
    # r1 < 1, r2 < 1, r3 < 1


def getqt(r1, r2, r3, r4, angle):
    Q = 2 * sin(angle)**2 * (r4*r3**2 - r2**2)
    T0 = sin(angle) / cos(angle)
    T1 = r1 * sin(angle) / sqrt(1.0 - r1**2 * sin(angle)**2)
    T2 = r2 * sin(angle) / sqrt(1.0 - r2**2 * sin(angle)**2)
    T3 = r3 * sin(angle) / sqrt(1.0 - r3**2 * sin(angle)**2)
    return Q, T0, T1, T2, T3


def ppr1(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r1.

    The equation is generated by Mathematica, see Zhu 2012.
    Limitation is no Vp critical angle (alpha1 > alpha2).

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    Q, T0, T1, T2, T3 = getqt(r1, r2, r3, r4, angle)

    # coefficient for T1 T2 T3
    tc1 = (1 + Q)**2
    tc2 = (r4 - Q)**2 
    tc3 = (r4 - Q - 1)**2

    # Notation:
    # term, page #, counting #
    # tm_p#_#
    tm_p1_1 = r4 / r1 * T1**3 * T2
    tm_p1_2 = r4 / r1 * T1 * T2
    # tm_p1_2 = r4 / r1 * T1 * T2
    # tm_p1_1 = tm2 * T1**2
    tm_p1_3 = tc2 / r1 * T1**3 * T3
    tm_p1_4 = tc2 / r1 * T1 * T3
    tm_p1_5 = tc3 / r1 * T0 * T1**3 * T2 * T3
    tm_p1_6 = tc3 / r1 * T0 * T1 * T2 * T3

    tm_b1 = tm_p1_1 + tm_p1_2 + tm_p1_3 + tm_p1_4 + tm_p1_5 + tm_p1_6

    tm_p1_7 = Q**2 + r4 * T1 * T2
    tm_p1_8 = tc2 * T1 * T3 - r4 * T0 * T3
    tm_p1_9 = - tc3 * T0 * T1 * T2 * T3
    tm_p2_1 = - tc1 * T0 * T2

    tm_b2 = tm_p1_7 + tm_p1_8 + tm_p1_9 + tm_p2_1

    tm_c1 = - tm_b1 * tm_b2
    # -- over above -- #

    tm_p2_2 = tm_p1_7
    tm_p2_3 = tc2 * T1 * T3 + r4 * T0 * T3
    tm_p2_4 = - tm_p1_9
    tm_p2_5 = - tm_p2_1

    tm_b3 = tm_p2_2 + tm_p2_3 + tm_p2_4 + tm_p2_5

    tm_c2 = tm_b3**2

    tm_c3 = tm_c1 / tm_c2
    # -- over above -- #

    tm_p2_6 = tm_p1_1
    tm_p2_7 = tm_p1_2
    tm_p2_8 = tm_p1_3
    tm_p2_9 = tm_p1_4
    tm_p2_10 = - tm_p1_5
    tm_p2_11 = - tm_p1_6

    tm_b4 = tm_p2_6 + tm_p2_7 + tm_p2_8 + tm_p2_9 + tm_p2_10 + tm_p2_11

    tm_p2_12 = tm_p1_7
    tm_p3_1 = tm_p2_3
    tm_p3_2 = - tm_p1_9
    tm_p3_3 = - tm_p2_1

    tm_b5 = tm_p2_12 + tm_p3_1 + tm_p3_2 + tm_p3_3

    tm_c4 = tm_b4 / tm_b5

    tm_c5 = tm_c3 + tm_c4

    grad = tm_c5
    return grad


def ppr2(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r2.

    The equation is generated by Mathematica, see Zhu 2012.
    Limitation is no Vp critical angle (alpha1 > alpha2).

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r2
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    Q, T0, T1, T2, T3 = getqt(r1, r2, r3, r4, angle)

    # coefficient for T1 T2 T3
    tc1 = (1 + Q)
    tc2 = (r4 - Q)
    tc3 = (r4 - Q - 1)

    tc4 = 8 * r2 * sin(angle)**2

    # Notation:
    # term, page #, counting #
    # tm_p#_#
    tm_p1_1 = - tc4 * Q
    tm_p1_2 = r4 / r2 * T1 * T2**3
    tm_p1_3 = r4 / r2 * T1 * T2
    tm_p1_4 = tc2 * tc4 * T1 * T3
    tm_p1_5 = tc3 * tc4 * T0 * T1 * T2 * T3
    tm_p1_6 = tc3**2 / r2 * T0 * T1 * T2**3 * T3
    # tm_p1_7 = tm_p1_6 / T2**2
    tm_p1_7 = tc3**2 / r2 * T0 * T1 * T2 * T3
    tm_p1_8 = - tc1 * tc4 * T0 * T2
    tm_p1_9 = tc1**2 / r2 * T0 * T2**3
    tm_p1_10 = tc1**2 / r2 * T0 * T2

    tm_b1 = tm_p1_1 + tm_p1_2 + tm_p1_3 + tm_p1_4 + tm_p1_5 \
        + tm_p1_6 + tm_p1_7 + tm_p1_8 + tm_p1_9 + tm_p1_10

    tm_p1_11 = Q**2 + r4 * T1 * T2
    tm_p2_1 = tc2**2 * T1 * T3
    tm_p2_2 = - r4 * T0 * T3
    # tm_p2_3 = - tm_p1_7 * r2
    tm_p2_3 = - tc3**2 * T0 * T1 * T2 * T3
    tm_p2_4 = - tc1**2 * T0 * T2

    tm_b2 = tm_p1_11 + tm_p2_1 + tm_p2_2 + tm_p2_3 + tm_p2_4

    tm_c1 = - tm_b1 * tm_b2

    tm_p2_5 = tm_p1_11
    tm_p2_6 = tm_p2_1
    tm_p2_7 = - tm_p2_2
    tm_p2_8 = - tm_p2_3
    tm_p2_9 = - tm_p2_4

    tm_c2 = tm_p2_5 + tm_p2_6 + tm_p2_7 + tm_p2_8 + tm_p2_9

    tm_c2 = tm_c2**2

    tm_d1 = tm_c1 / tm_c2

    tm_p2_10 = tm_p1_1
    tm_p2_11 = tm_p1_2
    tm_p2_12 = tm_p1_3
    tm_p2_13 = tm_p1_4
    tm_p2_14 = - tm_p1_5
    tm_p2_15 = - tm_p1_6
    tm_p2_16 = - tm_p1_7
    tm_p3_1 = - tm_p1_8
    tm_p3_2 = - tm_p1_9
    tm_p3_3 = - tm_p1_10

    tm_c3 = tm_p2_10 + tm_p2_11 + tm_p2_12 + tm_p2_13 + tm_p2_14 \
        + tm_p2_15 + tm_p2_16 + tm_p3_1 + tm_p3_2 + tm_p3_3

    tm_p3_4 = tm_p1_11
    tm_p3_5 = tm_p2_1
    tm_p3_6 = - tm_p2_2
    tm_p3_7 = - tm_p2_3
    tm_p3_8 = - tm_p2_4

    tm_c4 = tm_p3_4 + tm_p3_5 + tm_p3_6 + tm_p3_7 + tm_p3_8

    tm_d2 = tm_c3 / tm_c4

    grad = tm_d1 + tm_d2
    return grad


def ppr3(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r3.

    The equation is generated by Mathematica, see Zhu 2012.
    Limitation is no Vp critical angle (alpha1 > alpha2).

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r3
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    Q, T0, T1, T2, T3 = getqt(r1, r2, r3, r4, angle)

    # coefficient for T1 T2 T3
    tc1 = (1 + Q)
    tc2 = (r4 - Q)
    tc3 = (r4 - Q - 1)

    tc4 = 8 * r3 * r4 * sin(angle) ** 2

    # Notation:
    # term, page  # , counting #
    # tm_p  # _#
    tm_p1_1 = tc4 * Q
    tm_p1_2 = - tc2 * tc4 * T1 * T3
    tm_p1_3 = tc2 ** 2 / r3 * T1 * T3 ** 3
    tm_p1_4 = tc2 ** 2 / r3 * T1 * T3
    tm_p1_5 = r4 / r3 * T0 * T3 ** 3
    tm_p1_6 = r4 / r3 * T0 * T3
    tm_p1_7 = - tc3 * tc4 * T0 * T1 * T2 * T3
    tm_p1_8 = tc3 ** 2 / r3 * T0 * T1 * T2 * T3 ** 3
    tm_p1_9 = tc3 ** 2 / r3 * T0 * T1 * T2 * T3
    tm_p1_10 = tc1 * tc4 * T0 * T2

    tm_b1 = tm_p1_1 + tm_p1_2 + tm_p1_3 + tm_p1_4 + tm_p1_5 \
        + tm_p1_6 + tm_p1_7 + tm_p1_8 + tm_p1_9 + tm_p1_10

    tm_p2_1 = Q ** 2 + r4 * T1 * T2
    tm_p2_2 = tc2 ** 2 * T1 * T3
    tm_p2_3 = - r4 * T0 * T3
    tm_p2_4 = - tc3 ** 2 * T0 * T1 * T2 * T3
    tm_p2_5 = - tc1 ** 2 * T0 * T2

    tm_b2 = tm_p2_1 + tm_p2_2 + tm_p2_3 + tm_p2_4 + tm_p2_5

    tm_c1 = - tm_b1 * tm_b2

    tm_p2_6 = tm_p2_1
    tm_p2_7 = tm_p2_2
    tm_p2_8 = - tm_p2_3
    tm_p2_9 = - tm_p2_4
    tm_p2_10 = - tm_p2_5

    tm_c2 = tm_p2_6 + tm_p2_7 + tm_p2_8 + tm_p2_9 + tm_p2_10

    tm_c2 = tm_c2 ** 2

    tm_d1 = tm_c1 / tm_c2

    tm_p2_11 = tm_p1_1
    tm_p2_12 = tm_p1_2
    tm_p2_13 = tm_p1_3
    tm_p2_14 = tm_p1_4
    tm_p2_15 = - tm_p1_5
    tm_p2_16 = - tm_p1_6
    tm_p3_1 = - tm_p1_7
    tm_p3_2 = - tm_p1_8
    tm_p3_3 = - tm_p1_9
    tm_p3_4 = - tm_p1_10

    tm_c3 = tm_p2_11 + tm_p2_12 + tm_p2_13 + tm_p2_14 + tm_p2_15 \
        + tm_p2_16 + tm_p3_1 + tm_p3_2 + tm_p3_3 + tm_p3_4

    tm_p3_5 = tm_p2_1
    tm_p3_6 = tm_p2_2
    tm_p3_7 = - tm_p2_3
    tm_p3_8 = - tm_p2_4
    tm_p3_9 = - tm_p2_5

    tm_c4 = tm_p3_5 + tm_p3_6 + tm_p3_7 + tm_p3_8 + tm_p3_9

    tm_d2 = tm_c3 / tm_c4

    grad = tm_d1 + tm_d2
    return grad


def ppr4(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r4.

    The equation is generated by Mathematica, see Zhu 2012.
    Limitation is no Vp critical angle (alpha1 > alpha2).

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r4
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    Q, T0, T1, T2, T3 = getqt(r1, r2, r3, r4, angle)

    # coefficient for T1 T2 T3
    tc1 = (1 + Q)
    tc2 = (r4 - Q)
    tc3 = (r4 - Q - 1)

    tc4 = 4 * r3 ** 2 * sin(angle) ** 2
    tc5 = 2 * (1 - 2 * r3 ** 2 * sin(angle) ** 2)

    # Notation:
    # term, page  # , counting #
    # tm_p  # _#
    tm_p1_1 = tc4 * Q
    tm_p1_2 = T1 * T2
    tm_p1_3 = tc2 * tc5 * T1 * T3
    tm_p1_4 = T0 * T3
    tm_p1_5 = tc3 * tc5 * T0 * T1 * T2 * T3
    tm_p1_6 = tc1 * tc4 * T0 * T2

    tm_b1 = tm_p1_1 + tm_p1_2 + tm_p1_3 + tm_p1_4 + tm_p1_5 + tm_p1_6

    tm_p1_7 = Q ** 2 + r4 * T1 * T2
    tm_p1_8 = tc2 ** 2 * T1 * T3
    tm_p1_9 = - r4 * T0 * T3
    tm_p1_10 = - tc3 ** 2 * T0 * T1 * T2 * T3
    tm_p1_11 = - tc1 ** 2 * T0 * T2

    tm_b2 = tm_p1_7 + tm_p1_8 + tm_p1_9 + tm_p1_10 + tm_p1_11

    tm_c1 = - tm_b1 * tm_b2

    tm_p2_1 = tm_p1_7
    tm_p2_2 = tm_p1_8
    tm_p2_3 = - tm_p1_9
    tm_p2_4 = - tm_p1_10
    tm_p2_5 = - tm_p1_11

    tm_c2 = tm_p2_1 + tm_p2_2 + tm_p2_3 + tm_p2_4 + tm_p2_5

    tm_c2 = tm_c2 ** 2

    tm_d1 = tm_c1 / tm_c2

    tm_p2_6 = tm_p1_1
    tm_p2_7 = tm_p1_2
    tm_p2_8 = tm_p1_3
    tm_p2_9 = - tm_p1_4
    tm_p2_10 = - tm_p1_5
    tm_p2_11 = - tm_p1_6

    tm_c3 = tm_p2_6 + tm_p2_7 + tm_p2_8 + tm_p2_9 + tm_p2_10 + tm_p2_11

    tm_p2_12 = tm_p1_7
    tm_p2_13 = tm_p1_8
    tm_p2_14 = - tm_p1_9
    tm_p2_15 = - tm_p1_10
    tm_p3_1 = - tm_p1_11

    tm_c4 = tm_p2_12 + tm_p2_13 + tm_p2_14 + tm_p2_15 + tm_p3_1

    tm_d2 = tm_c3 / tm_c4

    grad = tm_d1 + tm_d2
    return grad


def psct(r1, r2, r3, r4, angle):
    """Get the common terms for PS frechet derivatives"""
    # --- constantly used terms ---
    sin12 = sin(angle) ** 2
    r12 = r1 * r1
    r22 = r2 * r2
    r32 = r3 * r3
    r42 = r4 * r4
    q1 = sqrt(1 - sin12)
    q2 = sqrt(1 - r12 * sin12)
    q3 = sqrt(1 - r22 * sin12)
    q4 = sqrt(1 - r32 * sin12)
    Q = 2 * sin12 * (r4 * r32 - r22)
    a = r4 - Q - 1
    b = r4 - Q
    c = 1 + Q
    d = 2 * (r4 * r3 / r1 - r22 / (r1 * r3))
    e = a - r1 * d * q1 * q4
    f = a - d * q2 * q3 * r3 / r2
    # --- self defined terms ---
    g = r22 / (r12 * r3) - (r3 * r4) / r12
    h = r1 * sin12
    i = r2 * sin12
    j = r3 * sin12
    k = r4 * sin12
    l = r22 / (r1 * r32) + r4 / r1
    m = 1 - 2 * r32 * sin12
    n = q2 * q3 / r1 + r2 * q1 * q4 / r3
    sin2 = sin(2 * angle)
    b2 = b * b
    c2 = c * c
    return q1, q2, q3, q4, a, b, c, d, e, f, g, h, i, j, k, l, m, n, \
        sin12, sin2, b2, c2, r12, r32


def psr1(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r1.

    The equation is generated by Mathematica, see Zhu 2014.
    Limitation is no Vp critical angle (alpha1 > alpha2).
    Previous authors: Ting Gong, Xinfa Zhu, 2013

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    #
    q1, q2, q3, q4, a, b, c, d, e, f, g, h, i, j, k, l, m, n, \
        sin12, sin2, b2, c2, r12, r32 = psct(r1, r2, r3, r4, angle)
    #
    # ======= left half =======
    # ---- upper half ----
    t1 = a * b + d * q2 * q4 * c
    t2 = i * q4 * c2 / (r3 * q2)
    t3 = r2 * q2 * q4 * c2 / (r12 * r3)
    t4 = b * c * (- sin12 * q3 / q2 - q2 * q3 / r12)
    t5 = i * f
    t6 = -2 * r1 * g * q1 * q4 - d * q1 * q4
    t7 = r1 * d * j * q3 / (r2 * q2) - 2 * r3 * g * q2 * q3 / r2
    t8 = i * e * t7
    tmp1 = -t2 - t3 + t4 + t5 * t6 + t8
    Tlu = t1 * tmp1 * sin2
    #
    # ---- bottom half ----
    p1 = q1 * q3 * b2
    p2 = r2 * q2 * q4 * c2 / (r1 * r3)
    p3 = b * c * n
    p4 = i * f * e
    tmp2 = p1 + p2 + p3 + p4
    Tld = tmp2 * tmp2
    #
    # ======= right half =======
    # ---- upper half ----
    t13 = h * d * q4 * c / q2
    t14 = 2 * g * q2 * q4 * c
    Tru = sin2 * (-t13 + t14)
    #
    # ---- bottom half ----
    Trd = tmp2
    #
    grad = Tlu / Tld - Tru / Trd
    return grad


def psr2(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r2.

    The equation is generated by Mathematica, see Zhu 2014.
    Limitation is no Vp critical angle (alpha1 > alpha2).
    Previous authors: Ting Gong, Xinfa Zhu, 2013

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    #
    q1, q2, q3, q4, a, b, c, d, e, f, g, h, i, j, k, l, m, n, \
        sin12, sin2, b2, c2, r12, r32 = psct(r1, r2, r3, r4, angle)
    #
    # ======= left half =======
    # ---- upper half ----
    t1 = a * b + d * q2 * q4 * c
    t2 = 8 * i * q1 * q3 * b
    t3 = i * b2 * q1 / q3
    t4 = 8 * r2 * i * q2 * q4 * c / (r1 * r3)
    t5 = q2 * q4 * c2 / (r1 * r3)
    t6 = b * c * (- i * q2 / (r1 * q3) + q1 * q4 / r3)
    t7 = 4 * i * b * n
    t8 = 4 * i * c * n
    t9 = i * f * 4 * (i + r2 * q1 * q4 / r3)
    t10 = 4 * i + d * j * q2 / q3 + 4 * q2 * q3 / r1 + r3 * d * q2 * q3 / r12
    t11 = i * t10 * e
    t12 = sin12 * f * e
    tmp1 = t2 - t3 - t4 + t5 + t6 - t7 + t8 + t9 + t11 + t12
    Tlu = t1 * tmp1 * sin2
    #
    # ---- bottom half ----
    p1 = q1 * q3 * b2
    p2 = r2 * q2 * q4 * c2 / (r1 * r3)
    p3 = b * c * n
    p4 = i * f * e
    tmp2 = p1 + p2 + p3 + p4
    Tld = tmp2 * tmp2
    #
    # ======= right half =======
    # ---- upper half ----
    t13 = 4 * d * i * q2 * q4
    t14 = 4 * i * (a + b)
    t15 = 4 * r2 * q2 * q4 * c / (r1 * r3)
    tmp3 = -t13 + t14 - t15
    Tru = sin2 * tmp3
    #
    # ---- bottom half ----
    Trd = tmp2
    grad = Tlu / Tld - Tru / Trd
    return grad


def psr3(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r3.

    The equation is generated by Mathematica, see Zhu 2014.
    Limitation is no Vp critical angle (alpha1 > alpha2).
    Previous authors: Ting Gong, Xinfa Zhu, 2013

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    #
    q1, q2, q3, q4, a, b, c, d, e, f, g, h, i, j, k, l, m, n, \
        sin12, sin2, b2, c2, r12, r32 = psct(r1, r2, r3, r4, angle)
    #
    # ======= left half =======
    # ---- upper half ----
    t1 = a * b + d * q2 * q4 * c
    t2 = 8 * r3 * k * q1 * q3 * b
    t3 = 8 * r2 * k * q2 * q4 * c / r1
    t4 = i * q2 * c2 / (r1 * q4)
    t5 = r2 * q2 * q4 * c2 / (r1 * r32)
    t6 = b * c * (-i * q1 / q4 - r2 * q1 * q4 / r32)
    t7 = 4 * r3 * k * b * n
    t8 = 4 * r3 * k * c * n
    t9 = i * f * (-4 * r3 * k + r1 * d * j * q1 / q4 - 2 * r1 * l * q1 * q4)
    t10 = i * e * (-4 * r3 * k - 2 * r3 * l * q2 * q3 / r2 - d * q2 * q3 / r2)
    tmp1 = -t2 + t3 - t4 - t5 + t6 + t7 - t8 + t9 + t10
    Tlu = t1 * tmp1 * sin2
    #
    # ---- bottom half ----
    p1 = q1 * q3 * b2
    p2 = r2 * q2 * q4 * c2 / (r1 * r3)
    p3 = b * c * n
    p4 = i * f * e
    tmp2 = p1 + p2 + p3 + p4
    Tld = tmp2 * tmp2
    #
    # ======= right half =======
    # ---- upper half ----
    t11 = 4 * r3 * d * k * q2 * q4
    t12 = 4 * r3 * k * (a + b)
    t13 = d * j * q2 * c / q4
    t14 = 2 * l * q2 * q4 * c
    tmp3 = t11 - t12 - t13 + t14
    Tru = sin2 * tmp3
    #
    # ---- bottom half ----
    Trd = tmp2
    grad = Tlu / Tld - Tru / Trd
    return grad


def psr4(r1, r2, r3, r4, angle):
    """
    Zoeppritz partial derivative w.r.t. r4.

    The equation is generated by Mathematica, see Zhu 2014.
    Limitation is no Vp critical angle (alpha1 > alpha2).
    Previous authors: Ting Gong, Xinfa Zhu, 2013

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    physics_check(r1, r2, r3, r4, angle)
    angle = angle * pi / 180.0
    stability_check(r1, angle)
    #
    q1, q2, q3, q4, a, b, c, d, e, f, g, h, i, j, k, l, m, n, \
        sin12, sin2, b2, c2, r12, r32 = psct(r1, r2, r3, r4, angle)
    #
    # ======= left half =======
    # ---- upper half ----
    t1 = a * b + d * q2 * q4 * c
    t2 = 2 * q1 * q3 * m * b
    t3 = 4 * r2 * j * q2 * q4 * c / r1
    t4 = 2 * r3 * j * b * n
    t5 = m * c * n
    t6 = i * f * (m - 2 * r3 * q1 * q4)
    t7 = i * e * (m - 2 * r32 * q2 * q3 / (r1 * r2))
    tmp1 = t2 + t3 + t4 + t5 + t6 + t7
    Tlu = t1 * tmp1 * sin2
    #
    # ---- bottom half ----
    p1 = q1 * q3 * b2
    p2 = r2 * q2 * q4 * c2 / (r1 * r3)
    p3 = b * c * n
    p4 = i * f * e
    tmp2 = p1 + p2 + p3 + p4
    Tld = tmp2 * tmp2
    #
    # ======= right half =======
    # ---- upper half ----
    t8 = 2 * r3 * d * j * q2 * q4
    t9 = m * (a + b)
    t10 = 2 * r3 * q2 * q4 * c / r1
    tmp3 = t8 + t9 + t10
    Tru = sin2 * tmp3
    #
    # ---- bottom half ----
    Trd = tmp2
    grad = Tlu / Tld - Tru / Trd
    return grad


def pdn(r1, r2, r3, r4, angle, mode, rid, delta=0.001):
    """
    Calculate partial derivatives numerically by perturbation.

    Parameters
    ----------
    r1 : float
        Vp2 / Vp1
    r2 : float
        Vs1 / Vp1
    r3 : float
        Vs2 / Vp1
    r4 : float
        Ro2 / Ro1
    angle : float
        incident angle in degrees
    mode : str
        'PP' or 'PS'
    rid : int
        1-4 corresponds to r1, r2, r3, r4
    delta : float
        perturbation amount

    Returns
    -------
    grad : float
        gradient or partial derivative w.r.t. r1
    """
    a1, a2, gra = 0, 0, 0
    if mode is 'PP':
        a1, _ = rpp_cer1977(r1, r2, r3, r4, angle)
        if rid == 1:
            r1 += delta
        elif rid == 2:
            r2 += delta
        elif rid == 3:
            r3 += delta
        elif rid == 4:
            r4 += delta
        else:
            raise ValueError("Illegal ratio index")
        a2, _ = rpp_cer1977(r1, r2, r3, r4, angle)
        gra = (a2 - a1) / delta
    elif mode is 'PS':
        a1, _ = rps_cer1977(r1, r2, r3, r4, angle)
        if rid == 1:
            r1 += delta
        elif rid == 2:
            r2 += delta
        elif rid == 3:
            r3 += delta
        elif rid == 4:
            r4 += delta
        else:
            raise ValueError("Illegal ratio index")
        a2, _ = rps_cer1977(r1, r2, r3, r4, angle)
        gra = (a2 - a1) / delta
    else:
        raise ValueError("Unsupported wave mode")
    return gra


if __name__ == '__main__':
    main()
